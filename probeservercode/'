
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <openssl/ssl.h> 
#include <openssl/rand.h>
#include <openssl/x509.h>
#include <openssl/err.h>
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/pem.h>

#include "../common.h"
#include "probe_server.h"
#include "ssh-keyscan.h"

BIO *bio_err=0;

/* A simple error and exit routine*/
int err_exit(string)
  char *string;
  {
    fprintf(stderr,"%s\n",string);
    exit(0);
  }

/* Print SSL errors and exit*/
int berr_exit(string)
  char *string;
  {

    ERR_print_errors(bio_err);
    exit(-1);
  }


void destroy_ctx(ctx)
  SSL_CTX *ctx;
  {
    SSL_CTX_free(ctx);
  }

/*
void check_cert_chain(ssl,host)
  SSL *ssl;
  char *host;
  {
    X509 *peer;
    char peer_CN[256];
    
    if(SSL_get_verify_result(ssl)!=X509_V_OK)
      berr_exit("Certificate doesn't verify");

    // Check the cert chain. The chain length
    //  is automatically checked by OpenSSL when we
    //  set the verify depth in the ctx

    // Check the common name
    peer=SSL_get_peer_certificate(ssl);
    X509_NAME_get_text_by_NID(X509_get_subject_name(peer),
      NID_commonName, peer_CN, 256);
    if(strcasecmp(peer_CN,host))
    err_exit("Common name doesn't match host name");
  }
*/

/*
int verify_callback (int ok, X509_STORE_CTX *store)
{
    char data[256];

    if (!ok)
    {
        X509 *cert = X509_STORE_CTX_get_current_cert(store);
        int  depth = X509_STORE_CTX_get_error_depth(store);
        int  err = X509_STORE_CTX_get_error(store);

        fprintf(stderr, "-Error with certificate at depth: %i\n", depth);
        X509_NAME_oneline(X509_get_issuer_name(cert), data, 256);
        fprintf(stderr, "  issuer   = %s\n", data);
        X509_NAME_oneline(X509_get_subject_name(cert), data, 256);
        fprintf(stderr, "  subject  = %s\n", data);
        fprintf(stderr, "  err %i:%s\n", err, X509_verify_cert_error_string(err) );
    }

    return ok;
}
*/


#define LISTEN_PORT 2221
#define KEYFILE "../keys/probe_server.key"
#define CERTFILE "../keys/probe_server.cert"
#define NUM_HOLDERS 1024

SSL_CTX *initialize_ctx(char *keyfile, char*cert_file) {
    SSL_METHOD *meth;
    SSL_CTX *ctx;
    
    /* Global system initialization*/
    SSL_library_init();
    OpenSSL_add_all_algorithms(); 
    SSL_load_error_strings();
      
    /* An error write context */
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
   
    /* Create our context*/
    meth=SSLv3_server_method();
    ctx=SSL_CTX_new(meth);

    /* Load our keys and certificates*/
    if(!(SSL_CTX_use_certificate_file(ctx,cert_file,SSL_FILETYPE_PEM)))
      berr_exit("Couldn't read certificate file");

    if(!(SSL_CTX_use_PrivateKey_file(ctx,keyfile,SSL_FILETYPE_PEM)))
      berr_exit("Couldn't read key file");

    if(!SSL_CTX_check_private_key(ctx)) 
      berr_exit("Private key check failed");

    printf("Successfully loaded private key and certificate\n");
    return ctx;
  }
      

// returns 1 if this header was able to be processed by 
// the ssh-keyscan layer.  
int process_request(notary_header *hdr) {

	printf("processing request\n");
	char* data = (char*)(hdr + 1);
	int len = strlen(data);
	if(len > 1024) {
		printf("Ignoring request because domain name > 1024 bytes\n");
		return;
	}
	char *host = (char*) malloc(len);
	if(host == NULL) {
		printf("Malloc out of memory \n");
		exit(1);
	}
	strcpy(host, data);
	printf("We were asked to process a request for: %s \n", host);
	return do_host(host);
}


int main(int argc, char** argv) {

	SSL_CTX *ctx;
	int sockfd;
	const char *ip = "128.2.213.64";
	struct sockaddr_in server_addr, client_addr;
	int addrlen = sizeof(struct sockaddr_in);
	ssh_key_holder ssh_keys[NUM_HOLDERS];

	// Build the SSL context
	ctx=initialize_ctx(KEYFILE, CERTFILE);

	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1){
	    perror("socket creation");
	    return -1;
	}

	bzero(&server_addr, sizeof(struct sockaddr_in));
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(LISTEN_PORT);
	if(!inet_aton(ip, (struct in_addr *)&(server_addr.sin_addr))) {
		perror("error with inet_aton\n");
		exit(-1);
	}

	if (bind(sockfd, (struct sockaddr *) &server_addr,sizeof(server_addr)) < 0){ 
              	perror("ERROR on binding");
		exit(-1);
	}
 
	listen(sockfd,5);
    
	SSL *ssl;
	BIO *sbio;
	printf("waiting for an incoming connection on %s : %d \n",
		inet_ntoa(server_addr.sin_addr), LISTEN_PORT);
        int newsockfd = accept(sockfd, 
              	(struct sockaddr *) &client_addr, &addrlen);
        if (newsockfd < 0) {
             	perror("ERROR on accept");
		return -1;
	}
		
	sbio=BIO_new_socket(newsockfd, BIO_NOCLOSE);
	ssl=SSL_new(ctx);
	SSL_set_bio(ssl,sbio,sbio);

	if (SSL_accept(ssl)<=0){
	     	berr_exit("SSL Accept Error");
	}

	int bytes_read = 0;
	char buf[MAX_PACKET_LEN];
	int hdr_len = sizeof(notary_header);
	
	while(1) {
		printf("Successful SSL setup.  Waiting for requests.\n");
		// loop to keep reading requests sent by notary server
		int r = SSL_read(ssl, buf + bytes_read, 
			MAX_PACKET_LEN - bytes_read);
		printf("read %d bytes \n", r);
		int ret_val = SSL_get_error(ssl,r);
		if(ret_val == SSL_ERROR_ZERO_RETURN) {
			printf("Connection has been closed remotely\n");
			break;
		} else if(ret_val == SSL_ERROR_SYSCALL) {
			perror("Socket Syscall error");
			break;
		}else if(ret_val != SSL_ERROR_NONE) {
    			printf("SSL_read returned error. \n");
    			ERR_print_errors(bio_err);
			break;
		}
	
		bytes_read += r;
		if(bytes_read >= hdr_len) {
			notary_header *hdr = (notary_header*) buf;
			int pkt_len = ntohs(hdr->name_len) + hdr_len;
			if(pkt_len >= bytes_read) {
				// loop until the lower layer accepts
				// another connection
				while(!process_request(hdr)) {}
			}
			memmove(buf, buf + pkt_len,
				 MAX_PACKET_LEN - pkt_len);
			bytes_read -= pkt_len;
		}

		int num_holders_used = conloop(&ssh_keys, NUM_HOLDERS);
		printf("main server loop got %d holders back! ****** \n",
			num_holders_used);

	
  	} // end while

	SSL_free(ssl);
	close(newsockfd);
	close(sockfd);
}



