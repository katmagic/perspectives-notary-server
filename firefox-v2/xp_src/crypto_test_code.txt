/*
 this is code that is useful for debugging issues with the signature
 formats used by mozilla, but its needed for production.  I'm just stashing
 it here in case i need it again. 
*/

/* 

I created this function as a work-around for the fact that originally
I couldn't get our signatures to work with the standard mozilla 
signature verification.  However, the above code fixes that problem
by adding the correct DER-encoded data to the start of the signature
data.  I am keeping this code around for reference.  

PRBool VerifyData(unsigned char *data, unsigned int data_len,
                  unsigned char *sig, unsigned int sig_len,
                  char *key64, unsigned int key64_len)

{
    // Allocate an arena to handle the majority of the allocations
    PRArenaPool *arena;
	SECStatus ss;
    arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    if (!arena)
        return false;

    //DPRINTF(DEBUG_INFO, "Verify sees key = '%s' \n", key64); 

    // Base 64 decode the key
    SECItem keyItem;
    PORT_Memset(&keyItem, 0, sizeof(SECItem));
    if (!NSSBase64_DecodeBuffer(arena, &keyItem,key64,key64_len)) {
	DPRINTF(DEBUG_ERROR, "bad key b64 decode \n"); 
        PORT_FreeArena(arena, PR_FALSE);
        return false;
    }
    
    // Extract the public key from the data
    CERTSubjectPublicKeyInfo *pki = SECKEY_DecodeDERSubjectPublicKeyInfo(&keyItem);
    if (!pki) {
        PORT_FreeArena(arena, PR_FALSE);
	DPRINTF(DEBUG_ERROR, "bad key DER decode \n"); 
        return false;
    }
    SECKEYPublicKey *publicKey = SECKEY_ExtractPublicKey(pki);
    SECKEY_DestroySubjectPublicKeyInfo(pki);
    pki = nsnull;
    
    if (!publicKey) {
        PORT_FreeArena(arena, PR_FALSE);
	DPRINTF(DEBUG_ERROR, "bad key extract\n"); 
        return false;
    }

    DPRINTF(DEBUG_INFO, "key len = %d \n", publicKey->u.rsa.modulus.len); 
    
   SECItem sig_item;
   sig_item.type = siBuffer;
   sig_item.data = sig;
   sig_item.len = sig_len; 
    
   SECAlgorithmID algID; 
   SECOID_SetAlgorithmID(arena,&algID,SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION,NULL); 
    ss = VFY_VerifyDataWithAlgorithmID(data,
                                       data_len, publicKey,
                                       &sig_item,
									   &algID,
                                       NULL, NULL);


    // Clean up remaining objects
    SECKEY_DestroyPublicKey(publicKey);
    PORT_FreeArena(arena, PR_FALSE);

	return(ss == SECSuccess);
}
*/ 
/*
    printf("trying to dump to DER\n"); 
    SECItem result; 
    CERTSignedData sd; 
    memset(&sd, 0x0, sizeof(sd)); 
    sd.data.data = NULL; 
    sd.data.len = 0; 
    sd.signature = sig_item;
    sd.signature.len *= 8; 
    printf("new signature len = %d \n", sd.signature.len); 
    SECOID_SetAlgorithmID(arena,&sd.signatureAlgorithm,
		SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION,NULL); 
    SECStatus rv = DER_Encode(arena, &result, CERTSignedDataTemplate, &sd); 
    if(rv) 
	printf("fuck, encode failed\n"); 
    else  { 
	for(int i = 0; i < 30; i++) { 
          printf("%02x, ", result.data[i]); 
        }
        printf("\n sig data: \n"); 
	for(int i = 0; i < 10; i++) { 
          printf("%02x, ", sig_item.data[i]); 
        }
    }
    printf("\n"); 
*/
/*

NS_IMETHODIMP VerifyData2(unsigned char *data, unsigned int data_len,
                  unsigned char *sig64, unsigned int sig64_len,
                  char *key64, unsigned int key64_len, 
                                    PRBool *_retval)
{
    // Allocate an arena to handle the majority of the allocations
    PRArenaPool *arena;
    arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    if (!arena)
        return NS_ERROR_OUT_OF_MEMORY;

    // Base 64 decode the key
    SECItem keyItem;
    PORT_Memset(&keyItem, 0, sizeof(SECItem));
    if (!NSSBase64_DecodeBuffer(arena, &keyItem,
				key64, key64_len)) { 
                                //nsPromiseFlatCString(aPublicKey).get(),
                                //aPublicKey.Length())) {
	printf("bad base64 decode of key\n"); 
        PORT_FreeArena(arena, PR_FALSE);
        return NS_ERROR_FAILURE;
    }
    
    // Extract the public key from the data
    CERTSubjectPublicKeyInfo *pki = SECKEY_DecodeDERSubjectPublicKeyInfo(&keyItem);
    if (!pki) {
	printf("bad DER decode of key\n"); 
        PORT_FreeArena(arena, PR_FALSE);
        return NS_ERROR_FAILURE;
    }
    SECKEYPublicKey *publicKey = SECKEY_ExtractPublicKey(pki);
    SECKEY_DestroySubjectPublicKeyInfo(pki);
    pki = nsnull;
    
    if (!publicKey) {
        PORT_FreeArena(arena, PR_FALSE);
        return NS_ERROR_FAILURE;
    }
    
    // Base 64 decode the signature
    SECItem signatureItem;
    PORT_Memset(&signatureItem, 0, sizeof(SECItem));
    if (!NSSBase64_DecodeBuffer(arena, &signatureItem,
                                (const char*)sig64, sig64_len)) { 
				//nsPromiseFlatCString(aSignature).get(),
                                //aSignature.Length())) {
	printf("bad base64 decode of key\n"); 
        SECKEY_DestroyPublicKey(publicKey);
        PORT_FreeArena(arena, PR_FALSE);
        return NS_ERROR_FAILURE;
    }
    
    // Decode the signature and algorithm
    CERTSignedData sigData;
    PORT_Memset(&sigData, 0, sizeof(CERTSignedData));
    SECStatus ss = SEC_QuickDERDecodeItem(arena, &sigData, 
                                          CERT_SignatureDataTemplate,
                                          &signatureItem);
    if (ss != SECSuccess) {
	printf("bad DERdecode of signature\n"); 
        SECKEY_DestroyPublicKey(publicKey);
        PORT_FreeArena(arena, PR_FALSE);
        return NS_ERROR_FAILURE;
    }
    
    // Perform the final verification
    DER_ConvertBitString(&(sigData.signature));
    ss = VFY_VerifyDataWithAlgorithmID((const unsigned char*) data, 
					// nsPromiseFlatCString(aData).get(),
                                       data_len, //aData.Length() 
				       publicKey,
                                       &(sigData.signature),
                                       &(sigData.signatureAlgorithm),
                                       NULL, NULL);
    
    // Clean up remaining objects
    SECKEY_DestroyPublicKey(publicKey);
    PORT_FreeArena(arena, PR_FALSE);
   
    *_retval = (ss == SECSuccess);

    return NS_OK;
}
*/ 
/*
static DERTemplate SECAlgorithmIDTemplate[] = {
     { DER_SEQUENCE,
           0, NULL, sizeof(SECAlgorithmID) },
     { DER_OBJECT_ID,
           offsetof(SECAlgorithmID,algorithm), },
     { DER_OPTIONAL | DER_ANY,
           offsetof(SECAlgorithmID,parameters), },
     { 0, }
};



DERTemplate CERTSignedDataTemplate[] =
{
     { DER_SEQUENCE,
           0, NULL, sizeof(CERTSignedData) },
     { DER_ANY,
           offsetof(CERTSignedData,data), },
     { DER_INLINE,
           offsetof(CERTSignedData,signatureAlgorithm),
           SECAlgorithmIDTemplate, },
     { DER_BIT_STRING,
           offsetof(CERTSignedData,signature), },
     { 0, }
};


const SEC_ASN1Template CERT_SignatureDataTemplate[] =
{
    { SEC_ASN1_SEQUENCE,
        0, NULL, sizeof(CERTSignedData) },
    { SEC_ASN1_INLINE | SEC_ASN1_XTRN,
        offsetof(CERTSignedData,signatureAlgorithm),
        SEC_ASN1_SUB(SECOID_AlgorithmIDTemplate), },
    { SEC_ASN1_BIT_STRING,
        offsetof(CERTSignedData,signature), },
    { 0, }
};

void
sv_PrintAsHex(FILE *out, SECItem *data, char *m)
{
    unsigned i;

    if (m) fprintf(out, m);
    
    for (i = 0; i < data->len; i++) {
        if (i < data->len - 1) {
            fprintf(out, "%02x", data->data[i]);
        } else {
            fprintf(out, "%02x\n", data->data[i]);
            break;
        }
    }
}

void
sv_PrintObjectID(FILE *out, SECItem *oid, char *m)
{
    const char *name;
    SECOidData *oiddata;
   
    printf("\n oid len = %d \n", oid->len);  
    oiddata = SECOID_FindOID(oid);
    if (oiddata == NULL) {
        sv_PrintAsHex(out, oid, m);
        return;
    }
    name = oiddata->desc;

    if (m != NULL)
        fprintf(out, "%s", m);
    fprintf(out, "name: %s\n", name);
    sv_PrintAsHex(out, oid, "oid-hex: "); 
}

void
sv_PrintAlgorithmID(FILE *out, SECAlgorithmID *a, char *m)
{
    sv_PrintObjectID(out, &a->algorithm, m);
   
    printf("alg parameters len = %d \n", a->parameters.len);  
    if ((a->parameters.len != 2) ||
        (PORT_Memcmp(a->parameters.data, "\005\000", 2) != 0)) {
        /* Print args to algorithm */
        sv_PrintAsHex(out, &a->parameters, "Args=");
    }
    sv_PrintAsHex(out, &a->parameters, "Args=");
}

int
sv_PrintSignedData(CERTSignedData *sd)
{
 
     printf("lens: data = %d  sig = %d \n", 
		sd->data.len,  sd->signature.len); 
     sv_PrintAsHex(stdout, &sd->data, "data=");
     sv_PrintAlgorithmID(stdout, &sd->signatureAlgorithm, "signatureAlgorithm=");
     DER_ConvertBitString(&sd->signature);
     sv_PrintAsHex(stdout, &sd->signature, "signature=");
 
     return 0;
}
*/ 
/* 
PRBool crypto_test() { 

   //char *data = "hello";
   // from test-case
  char *sig64 = "MIGTMA0GCSqGSIb3DQEBBAUAA4GBAGGb2QkA8LcA+QZj1SoVFmMpVTd9P5Ac0Rjb" 
   "ldouMmngztMV/dxymVKCpknqelhsxTQ/zaqGZ4KKzcIffJa9jXi5XUD8XzDIKcFE" 
   "dQvti8oUNDPb6l1ybETI8LKh2ywyBCSZ/Q5BwUeS9nfx+4cAnu9YZf29SGljit+Y" 
   "XLPKZ+of"; 
   
 
// generated by my app
char *sig64 =
"MIGTMA0GCSqGSIb3DQEBBAUAA4GBAJKChfVVAspOodRtr1bW/dLZ2rxsgDqJcYpB"
"/0AuIegRqvMdwiXOl1rB7M4e+YHq9OiTnRMqqjl60g1uyJj2LXcS36Uxq3bjG1e8"
"W9h+yAuIn1YQv8pXxHrYBhXfSmcQqAeYsXs0vWor7U++drd13HT3BS9YoCN+ibCu"
"EhkIO/R3"; 

    char *key64 = "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAE0Ow4voLFzfAYf6PIVCT8CBz7Gts4/zWtAntmqk2CkvRw7KJJD9oB2RFjAVIhOIxSZN0GtLb4SjIMtDretJLIyd//UXx0lvOY8b8tc0XxpCnrMI6GPkmZ1oFZ2K9KSv7Fcega7fBsBvRuSZ1JsrdhW8xtCa1H7YqP9wnh4DYPssYhiNi/e9hbOHP3+spXxTyeTmJW6Xep8sd4j0pNdsQuV9SNd8Lv36+hkNEUCAwEAAQ==";

char *sig64 =
"MCgwDQYJKoZIhvcNAQEEBQADFwQBHA+vmKfajERtWj0Vc5VTDB+WX7aw2ve2ujpa"
"pEmaTGIwLOdINTopvGLP+rL+Xocw1MMY6W2XyWhDOIe5tItbTjG9bkXFrNx8NhcK"
"jnfurmBfpjFa8WcMsWmPCIF2eFVjWXxUxMOyDcwQvjGUkNIlEQ8rZJNwKlJAEEsE"
"AiMPHHRVIzscGnbtr+JWQKqzDvlO7VgD4dC2+9zddw1HphG3bV/MV6anAe+/rKoB";

char *key64 = 
"MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAE0Ow4voLFzfAYf6PIVCT8CBz7G"  
"ts4/zWtAntmqk2CkvRw7KJJD9oB2RFjAVIhOIxSZN0GtLb4SjIMtDretJLIyd//U" 
"Xx0lvOY8b8tc0XxpCnrMI6GPkmZ1oFZ2K9KSv7Fcega7fBsBvRuSZ1JsrdhW8xtC" 
"a1H7YqP9wnh4DYPssYhiNi/e9hbOHP3+spXxTyeTmJW6Xep8sd4j0pNdsQuV9SNd" 
"8Lv36+hkNEUCAwEAAQ==";
  
 
     printf("sig64 len = %u \n", (unsigned int)strlen(sig64)); 

    unsigned int key64_len = strlen(key64); 
    PRArenaPool *arena;
	SECStatus ss;
    arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    if (!arena)
        return false;

    //DPRINTF(DEBUG_INFO, "Verify sees key = '%s' \n", key64); 

    // Base 64 decode the key
    SECItem keyItem;
    PORT_Memset(&keyItem, 0, sizeof(SECItem));
    if (!NSSBase64_DecodeBuffer(arena, &keyItem,key64,key64_len)) {
	DPRINTF(DEBUG_ERROR, "bad key b64 decode \n"); 
        PORT_FreeArena(arena, PR_FALSE);
        return false;
    }
    
    // Extract the public key from the data
    CERTSubjectPublicKeyInfo *pki = SECKEY_DecodeDERSubjectPublicKeyInfo(&keyItem);
    if (!pki) {
        PORT_FreeArena(arena, PR_FALSE);
	DPRINTF(DEBUG_ERROR, "bad key DER decode \n"); 
        return false;
    }
    SECKEYPublicKey *publicKey = SECKEY_ExtractPublicKey(pki);
    SECKEY_DestroySubjectPublicKeyInfo(pki);
    pki = nsnull;
    
    if (!publicKey) {
        PORT_FreeArena(arena, PR_FALSE);
	DPRINTF(DEBUG_ERROR, "bad key extract\n"); 
        return false;
    }
    printf("all good so far\n");
 
     // Base 64 decode the signature
     SECItem signatureItem;
     PORT_Memset(&signatureItem, 0, sizeof(SECItem));
     if (!NSSBase64_DecodeBuffer(arena, &signatureItem,
                                 sig64, strlen(sig64))) {
         SECKEY_DestroyPublicKey(publicKey);
         PORT_FreeArena(arena, PR_FALSE);
         printf("could not base64 decode the signature\n"); 
         return false;
     }
     printf("dumping known signature: \n"); 
     for(int i = 0; i < 30; i++) { 
        printf("%02x, ", signatureItem.data[i]); 
     }
     // Decode the signature and algorithm
     CERTSignedData sigData;
     PORT_Memset(&sigData, 0, sizeof(CERTSignedData));
     ss = SEC_QuickDERDecodeItem(arena, &sigData, 
                                           CERT_SignatureDataTemplate,
                                           &signatureItem);
     if (ss != SECSuccess) {
         SECKEY_DestroyPublicKey(publicKey);
         PORT_FreeArena(arena, PR_FALSE);
	 printf("bad signature DER decode \n"); 
         return false;
     }

     printf("\n here is the PrintSignedData \n"); 

     sv_PrintSignedData(&sigData); 
  
    printf("signature was well-formed *************** \n");  
    return true; 
}
*/ 


